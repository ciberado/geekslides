import 'notie/dist/notie.css';
import notie from 'notie/dist/notie.js';
import { v4 as uuidv4 } from 'uuid';

import { hub } from './SimpleMqttClient';

class SyncController {

  uuid;

  slideshowController;
  emitting;

  /**
   * If desiredLocation is set to anything different of null, it means we should not
   * publish location events as they are being generated by a move created outside
   * the local slidedeck (and it would produce a deadlock as more than one instances would
   * be compiting for the desired state).
   */
  desiredLocation = null;

  constructor(slideshowController) {
    console.log(`Initializing SyncController.`);

    this.uuid = uuidv4();
  
    this.slideshowController = slideshowController;
    this.emitting = false;

    document.addEventListener('toggleEmission', 
      (evt) => this.toggleEmission());
    document.addEventListener('slideShown', 
      (evt) => this.#dispatchCurrentSlide(evt.detail.currentSlideIndex, evt.detail.lastPartialShownIndex));
    document.addEventListener('partialShown', 
      (evt) => this.#dispatchCurrentSlide(evt.detail.currentSlideIndex, evt.detail.lastPartialShownIndex));
    document.addEventListener('slideshowLoaded', 
      (evt) => this.#dispatchSlideshowLoaded(evt.detail.newBaseUrl, evt.detail.currentSlideIndex));

    document.addEventListener('startWhiteboardStroke', 
      evt => this.#dispatchWhiteboard(evt.detail.source.id, evt.type, false, evt.detail));
    document.addEventListener('endWhiteboardStroke', 
      evt => this.#dispatchWhiteboard(evt.detail.source.id, evt.type, false, evt.detail));
    document.addEventListener('whiteboardStroke', 
      evt => this.#dispatchWhiteboard(evt.detail.source.id, evt.type, false, evt.detail));
    document.addEventListener('clearWhiteboard', 
      evt => this.#dispatchWhiteboard(evt?.detail?.source.id, evt.type, false));

    document.addEventListener('whiteboardShown', 
      evt => this.#dispatchWhiteboard(evt.detail.source.id, evt.type, true));
    document.addEventListener('whiteboardHidden', 
      evt => this.#dispatchWhiteboard(evt.detail.source.id, evt.type, true));

    hub.subscribeListener('slides', (p) => this.#processSlideMessage(JSON.parse(p)));
    hub.subscribeListener('slideShowLoaded', (p) => this.#processSlideMessage(JSON.parse(p)));
    hub.subscribeListener('slides/whiteboard', (p) => this.#processWhiteboard(JSON.parse(p)));
  }

  toggleEmission(optionalNewValue) {
    this.emitting = (optionalNewValue === undefined) ? !this.emitting : optionalNewValue;
    if (this.emitting === true) {
      const message = 'Emitting current slidedeck position';
      notie.alert({type : 'info', text : message, position : 'bottom'});
      this.#dispatchTakeControl();  
    } else {
      const message = 'Deactivating current slidedeck position emission.';
      notie.alert({type : 'warning', text : message, position : 'bottom'});
    }
    return this.emitting;
  }


  #dispatchTakeControl() {
    const payload = {
      action: 'control', 
      syncControllerUuid : this.uuid
    };
    hub.emitMessage('slides', payload);
  }

  #dispatchCurrentSlide(currentSlideIndex, lastPartialShownIndex) {
    // don't try to force external state if we are trying to reach one sent by other instance.    
    if (this.desiredLocation !== null) {
      return;
    }
    
    if (this.emitting === true) {
      const payload = {
        action: 'location', 
        baseUrl: this.slideshowController.baseUrl,
        currentSlideIndex, 
        lastPartialShownIndex,
        syncControllerUuid : this.uuid
      };
      hub.emitMessage('slides', payload);
    }
  }

  #dispatchSlideshowLoaded(newBaseUrl, currentSlideIndex) {
    if (this.emitting === false) return;

    const payload = {
      action: 'slideShowLoaded', 
      newBaseUrl, 
      currentSlideIndex,
      syncControllerUuid : this.uuid
    };
    hub.emitMessage('slides', payload, 0, true);
  }

  #processSlideMessage(message) {
    // don't process messages generated by this browser
    if (message.syncControllerUuid === this.uuid) return;

    if (message.action === 'control') {
      // Inform there is another instance controlling the slideshow
      if (this.emitting === true) {
        const message = 'Another instance is also controlling the slideshow.';
        notie.alert({type : 'warning', text : message, position : 'bottom'});
      }
    } else if (message.action === 'location') {
      if (this.emitting === true) {
        //this.toggleEmission(false);
      }
      if (this.slideshowController.baseUrl !== message.baseUrl) {
        this.slideshowController.changeSlideshowContent(
          message.baseUrl,
          message.currentSlideIndex
        );
      } else {
        this.desiredLocation = {
          desiredIndex : message.currentSlideIndex, 
          desiredPartial : message.lastPartialShownIndex
        };
        this.slideshowController.slideshow.gotoSlideIndex(
          this.desiredLocation.desiredIndex, this.desiredLocation.desiredPartial);
        this.desiredLocation = null;
      }
    } else if (message.action === 'slideShowLoaded') {
      if (this.emitting === false) {
        this.slideshowController.changeSlideshowContent(message.newBaseUrl, message.currentSlideIndex);
      }
    }
  }

  #dispatchWhiteboard(id, action, retain, detail){
    id = id ? id : null;
    detail = detail ? Object.assign(detail) : {};
    delete detail.source;
    if (this.emitting === false) return;
    const payload = {
      syncControllerUuid : this.uuid,
      action, 
      id, 
      detail
    };
    hub.emitMessage('slides/whiteboard', payload, 0, retain);
  }

  #processWhiteboard(message) {
    // don't process messages generated by this browser
    if (message.syncControllerUuid === this.uuid) return;

    // process it by generating an event from the corresponding source
    delete message.syncControllerUuid
    const elem = message.id ? 
                 document.getElementById(message.id) : this.slideshowController.slideshow.getCurrentSlideElem().querySelector('.whiteboard');
    const detail = Object.assign(message.detail ? message.detail : {});
    detail.action = message.action;
    let evt = new CustomEvent('remoteWhiteboard', { detail });
    elem.dispatchEvent(evt);
  }
}

export default SyncController;